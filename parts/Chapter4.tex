\section{Описание практической части}
\label{sec:Chapter4} \index{Chapter4}

\subsection{Формат хранения сигнатуры}

Выбранный формат сигнатуры - это набор последовательности подстрок. Представим требования хранения выбранного формата сигнатур в памяти:

\begin{enumerate}
    \item Результатом работы оригинального алгоритма LASER является одна последовательность подстрок.
    Предполагается, что подстроки отделены специальным символом, но так как в бинарных протоколах используются все значения байта, то
    нельзя найти такой символ. Однако предположим, что такой символ найдется и заметим, что в момент уточнения сигнатуры, алгоритм LCS, который лежит в основе LASER,
    не чувствителен к наличию этого символа во входном потоке байт, т.к. это специальный символ и во втором потоке байт его нет.
    Значит последовательность подстрок необходимо хранить последовательно без разделяющего символа. Это также уменьшит размер матрицы направлений.
    \item Для того, чтобы находить сами подстроки, например, с целью напечатать их, будем хранить смещения на каждую подстроку.
    \item Для того, чтобы постоянно не расчитывать общую длину последовательности подстрок, будем хранить этот размер.
    \item Необходимо также хранить и само количество подстрок, чтобы опредилить количество смещений.
    \item Так как строка в \verb!C!/\verb!C++! должна быть нуль-терменированна, то в конце всех подстрок будет стоять \textquotesingle $\backslash 0$ \textquotesingle.
    Сами подстроки дополнительно на \textquotesingle $\backslash 0$ \textquotesingle не оканчиваются.
    \item Так же для быстрого доступа к подстроке и быстрого расчёта её длины, будем хранить $n + 1$ смещение, где $n$ - количество подстрок,
    т.е. $n$-смещений - это смещение каждой подстроки относительно начала последовательности подстрок и ещё одно смещение - \textquotesingle $\backslash 0$ \textquotesingle.
    Тогда размер подстроки можно легко вычислить через разницу смещений. Первое смещение всегда равно 0, его можно не хранить, но хранится для однородности вычислений.
    \item Так как размер последовательности подстрок небольшой, то такое представление последовательности подстрок должно быть cache-friendly.
    Значит для представления набора последовательностей подстрок каждая последовательность должна быть локализирована.
    \item Естественно надо хранить количество последовательностей и их смещения для доступа к ним.
\end{enumerate}


Таким образом, данным требованиям удовлетворяет следующее представление:


\begin{figure}[H]
    \begin{center}
        \includesvg[width = 1\textwidth]{images/signature}
        \caption{Формат хранения сигнатуры.}
    \end{center}
\end{figure}


\subsection{Интеграция в архитектуру системы анализа трафика}

Система анализа высокоскоростного трафика, разрабатываемая в ИСП РАН, состоит из обрабатывающих модулей. В рамках данной задачи использовалось несколько схем обрабатывающих модулей.
На схемах ниже оранжевым обозначены модули, которые уже были реализованы в системе, а фиолетовым - те, которые появились в процессе работы над задачей.

Сначала использовались схемы без сборки TCP-сессий: для них использовался оригинальный алгоритм LASER,
который работает c первыми N пакетами, а не с первыми n-байт полезной нагрузки, так как конечной сигнатурой LASER является сигнатура-пакета, а не потока.

\begin{figure}[H]
    \begin{center}
        \includesvg[width = 0.8\textwidth]{images/scheme_auto_signature_generation}
        \caption{Схема генерации сигнатуры без сборки TCP-сессий.}
    \end{center}
\end{figure}

\begin{figure}[H]
    \begin{center}
        \includesvg[width = 0.8\textwidth]{images/scheme_auto_signature_classifier}
        \caption{Схема классификации трафика без сборки TCP-сессий.}
    \end{center}
\end{figure}

Поговорим про каждый модуль более подробно:

\begin{itemize}
    \item Producer: обрабатывает поступающий ему на вход pcap-файл, разделяя его на пакеты.
    Также может поставлять пакеты с интерфейса устройства в режиме реального времени.
    \item Defragmenter: осуществляет дефрагментацию IP пакета, если он был разделён на фрагменты.
    \item FlowGenerator: приписывает каждому пакету номер потока, к которому он принадлежит по
    IP-адресу источника, IP-адресу назначения, порту источника, порту назначения и используемый протокол транспортного уровня. Есть возможность объединять потоки, идущие в две стороны.
    \item FlowCollector: сохраняет приходящие пакеты и отправляет их в AutoSignatureController и ждёт от него сигнала.
    Как только приходит сигнал от AutoSignatureController с идентификатором потока, FlowCollector отправляет все сохранённые пакеты этого потока в модуль AutoSignatureGenerator.
    \item AutoSignatureController: собирает статистику по каждому потоку и отправляет сигнал FlowCollector с идентификатором того потока,
    который выполнил некоторые требования выбранного алгоритма.
    Например, для LASER это ограничение по пакетам: в потоке должно присутствовать хотя бы N пакетов, последующие пакеты будут проигнорированы.
    \item AutoSignatureGenerator: выполняет генерацию сигнатуры на основе приходящих пакетов и передаёт полученную сигнатуру в AutoSignatureSaver.
    \item AutoSignatureSaver: выполняет десериализацию сигнатуры и сохраняет в файл в формате .json.
    \item AutoSignatureClassifier: классифицирует приходящий трафик, сопоставляя каждый пакет с набором сигнатур. Здесь считается, что сигнатура это сигнатура-пакета.
\end{itemize}

Для всех последующих других методов и других модификаций алгоритма LASER использовалась схема со сборкой TCP-сессии.

\begin{figure}[H]
    \begin{center}
        \includesvg[width = 0.95\textwidth]{images/scheme_auto_signature_generation_v2}
        \caption{Схема генерации сигнатуры со сборкой TCP-сессий.}
    \end{center}
\end{figure}

\begin{figure}[H]
    \begin{center}
        \includesvg[width = 0.95\textwidth]{images/scheme_auto_signature_classifier_v2}
        \caption{Схема классификации трафика со сборкой TCP-сессий.}
    \end{center}
\end{figure}

Отличия от предыдущих схем:

\begin{itemize}
    \item После дефрагментации пакетов стоит модуль SessionTcpReassembler.
    Он собирает TCP-сессию и отправляет полезную нагрузку дальше после завершения сборки (или при срабатывании настраиваемого таймера),
    все последующие модули работают с этой полезной нагрузкой. Если пришёл UDP-пакет, то просто пропускается дальше.
    \item AutoSignatureController использует ограничение на необходимую длину полезной нагрузки.
    \item AutoSignatureClassifier использует уже сигнатуры-потоков, так как сопоставление происходит по полезной нагрузке потока.
\end{itemize}

В ходе данной работы были разработаны следующие модули:
\begin{enumerate}
    \item AutoSignatureGenerator
    \item AutoSignatureClassifier
    \item AutoSignatureController
    \item AutoSignatureSaver
    \item SessionTcpReassembler
\end{enumerate}

Все новые модули были реализованы на языке \verb!C++!, так как все модули системы были реализованы на нём.
Это необходимо для обработки высокоскоростного трафика в режиме реального времени, так как
язык \verb!C++! позволяет писать высокопроизводительные программы.
Также для совместимости с SessionTcpReassembler были модифицированы модули FlowGenerator и FlowCollector,
которые теперь позволяют работать не только с пакетами в отдельности, но и с полезной нагрузкой TCP-сессии.

В конечном итоге после внедрения модулей было получено 2 пайплайна.
Первый позволяет генерировать сигнатуры потоков на основе их полезной нагрузки,
а второй использует эти сигнатуры для классификации трафика.
Разделение на 2 пайплайна выполнено из соображения их независимости.

\newpage
