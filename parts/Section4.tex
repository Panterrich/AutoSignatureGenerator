\section{Описание практической части}
\label{sec:Section4} \index{Section4}

\subsection{Формат хранения сигнатуры}

Выбранный формат сигнатуры - это набор последовательности подстрок. Представим требования хранения выбранного формата сигнатур в памяти:

\begin{enumerate}
    \item Результатом работы оригинального алгоритма LASER является одна последовательность подстрок.
    Предполагается, что подстроки отделены специальным символом, но так как в бинарных протоколах используются все значения байта, то
    нельзя найти такой символ. Однако предположим, что такой символ найдется и заметим, что в момент уточнения сигнатуры, алгоритм LCS, который лежит в основе LASER,
    не чувствителен к наличию этого символа во входном потоке байт, так как это специальный символ и во втором потоке байт его нет.
    Значит последовательность подстрок необходимо хранить последовательно без разделяющего символа. Это также уменьшит размер матрицы направлений.
    \item Для того, чтобы иметь доступ к самим подстрокам, например, с целью напечатать их, будем хранить смещения на каждую подстроку.
    \item Для того, чтобы постоянно не расчитывать общую длину последовательности подстрок, будем хранить этот размер.
    \item Необходимо также хранить и само количество подстрок, чтобы опредилить количество смещений.
    \item Так как строка в \verb!C!/\verb!C++! должна быть нуль-терменированна, то в конце всех подстрок будет стоять  `$\backslash 0$'.
    Сами подстроки дополнительно на `$\backslash 0$' не оканчиваются.
    \item Так же для быстрого доступа к подстроке и быстрого расчёта её длины, будем ещё будем хранить одно дополнительное смещение на `$\backslash 0$',
    то есть суммарно $n + 1$ смещение, где $n$ - количество подстрок. Каждое смещение расчитывается относительно начала последовательности подстрок.
    Тогда размер подстроки можно легко вычислить через разницу смещений. Первое смещение всегда равно 0, его можно не хранить, но хранится для однородности вычислений.
    \item Так как размер последовательности подстрок небольшой, то такое представление последовательности подстрок должно быть cache-friendly.
    Значит для представления набора последовательностей подстрок каждая последовательность должна быть локализирована.
    \item Естественно надо хранить количество последовательностей и их смещения для доступа к ним.
\end{enumerate}


Таким образом, данным требованиям удовлетворяет следующее представление:

\begin{figure}[H]
    \begin{center}
        \includesvg[width = 1\textwidth]{images/signature}
        \caption{Формат хранения сигнатуры.}
    \end{center}
\end{figure}

Были добавлены специальные поля для каждой подстроки: смещение и глубина.
Информация о смещении указывает начальную позицию для поиска подстроки в полезной нагрузке пакета,
а информация о глубине указывает, как далеко поиск должен продолжаться от местоположения смещения.
Если этой информации нет, то значения данных полей соответственно равны $0$ и $-1$.
Глубина равная $-1$ означает, что поиск требуется осуществлять до конца полезной нагрузки.
Данные поля помогают ускорить процесс поиска подстрок при сопоставлении сигнатуры.

\subsection{Интеграция в архитектуру системы анализа трафика}

Система анализа высокоскоростного трафика, разрабатываемая в ИСП РАН, состоит из обрабатывающих модулей.
В рамках данной задачи использовалось несколько схем обрабатывающих модулей, которые объединяются в схемы обработки.
На схемах ниже оранжевым обозначены модули, которые уже были реализованы в системе, а фиолетовым - те, которые появились в процессе работы над задачей.

Сначала использовались схемы без сборки TCP-сессий: для них использовался оригинальный алгоритм LASER,
который работает c первыми N пакетами, а не с первыми n-байт полезной нагрузки, так как конечной сигнатурой LASER является наибольшая сигнатура-пакета, а не потока.

\begin{figure}[H]
    \begin{center}
        \includesvg[width = 0.8\textwidth]{images/scheme_auto_signature_generation}
        \caption{Схема генерации сигнатуры без сборки TCP-сессий.}
    \end{center}
\end{figure}

\begin{figure}[H]
    \begin{center}
        \includesvg[width = 0.8\textwidth]{images/scheme_auto_signature_classifier}
        \caption{Схема классификации трафика без сборки TCP-сессий.}
    \end{center}
\end{figure}

Поговорим про каждый модуль более подробно:

\begin{itemize}
    \item \textbf{Producer}: обрабатывает поступающий ему на вход pcap-файл, разделяя его на пакеты.
    Также может поставлять пакеты с интерфейса устройства в режиме реального времени.
    \item \textbf{Defragmenter}: осуществляет дефрагментацию IP пакета, если он был разделён на фрагменты.
    \item \textbf{FlowGenerator}: приписывает каждому пакету номер потока, к которому он принадлежит по
    IP-адресу источника, IP-адресу назначения, порту источника, порту назначения и используемый протокол транспортного уровня. Есть возможность объединять потоки, идущие в две стороны.
    \item \textbf{FlowCollector}: сохраняет приходящие пакеты и отправляет их в модуль \\ AutoSignatureController и ждёт от него сигнала.
    Как только приходит сигнал от AutoSignatureController с идентификатором потока, FlowCollector отправляет все сохранённые пакеты этого потока в модуль AutoSignatureGenerator.
    \item \textbf{AutoSignatureController}: собирает статистику по каждому потоку и отправляет сигнал FlowCollector с идентификатором того потока,
    который выполнил некоторые требования выбранного алгоритма.
    Например, для LASER это ограничение по пакетам: в потоке должно присутствовать хотя бы N пакетов, последующие пакеты будут проигнорированы.
    \item \textbf{AutoSignatureGenerator}: выполняет генерацию сигнатуры на основе приходящих пакетов и передаёт полученную сигнатуру в AutoSignatureSaver.
    \item \textbf{AutoSignatureSaver}: выполняет десериализацию сигнатуры и сохраняет в файл в формате .json.
    \item \textbf{AutoSignatureClassifier}: классифицирует приходящий трафик, сопоставляя каждый пакет с набором сигнатур. Здесь считается, что сигнатура это сигнатура-пакета.
\end{itemize}

Для всех последующих других методов и других модификаций алгоритма LASER использовалась схема со сборкой TCP-сессии.

\begin{figure}[H]
    \begin{center}
        \includesvg[width = 0.95\textwidth]{images/scheme_auto_signature_generation_v2}
        \caption{Схема генерации сигнатуры со сборкой TCP-сессий.}
    \end{center}
\end{figure}

\begin{figure}[H]
    \begin{center}
        \includesvg[width = 0.95\textwidth]{images/scheme_auto_signature_classifier_v2}
        \caption{Схема классификации трафика со сборкой TCP-сессий.}
    \end{center}
\end{figure}

Отличия от предыдущих схем:

\begin{itemize}
    \item После дефрагментации пакетов стоит модуль SessionTcpReassembler.
    Он собирает TCP-сессию и отправляет полезную нагрузку дальше после завершения сборки (или при срабатывании настраиваемого таймера),
    все последующие модули работают с этой полезной нагрузкой. Если пришёл UDP-пакет, то просто пропускается дальше.
    \item AutoSignatureController использует ограничение на необходимую длину полезной нагрузки.
    \item AutoSignatureClassifier использует уже сигнатуры-потоков, так как сопоставление происходит по полезной нагрузке потока.
\end{itemize}

В ходе данной работы были разработаны следующие модули:
\begin{enumerate}
    \item AutoSignatureGenerator,
    \item AutoSignatureClassifier,
    \item AutoSignatureController,
    \item AutoSignatureSaver,
    \item SessionTcpReassembler.
\end{enumerate}

Так как все модули системы были реализованы на языке программирования \verb!C++!, то новые модули были реализованы также на нём.
\verb!C++! позволяет писать высокопроизводительные программы, что является необходимостью
для обработки высокоскоростного трафика в режиме реального времени.

Также для совместимости с SessionTcpReassembler были модифицированы модули FlowGenerator и FlowCollector,
которые теперь позволяют работать не только с пакетами в отдельности, но и с полезной нагрузкой TCP-сессии.

В конечном итоге после внедрения модулей было получено 2 пайплайна.
Первый позволяет генерировать сигнатуры потоков на основе их полезной нагрузки,
а второй использует эти сигнатуры для классификации трафика.
Разделение на 2 пайплайна выполнено из соображения их независимости.

\newpage
