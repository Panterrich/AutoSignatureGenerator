\section*{Приложение}
\addcontentsline{toc}{section}{Приложение}
\label{sec:Apendix} \index{Apendix}

Приведём сам алгоритм из статьи:

\begin{lstlisting}[language=PL/I, caption=Алгоритм LASER]
procedure Signature_Generation ()
    Flow_Pool {F1[]...Fx[]} <- Santized_packet_collector
    F1[] <- Iterate, packet dump for Flow 1
    F2[] <- Iterate, packet dump for Flow 2
    while i from 0 to packet_constraint do
        while j from 0 to packet_constraint do
            if |F1[i].packet_size - F2[j].packet_size| < threshold
            result_LCS <- LASER (F1[i], F1[j])
            LCS_Pool{} <- Append result_LCS, end if
        j++, end while
    i++, end while
    S <- select the longest from LCS_Pool
    while i from 0 to number of rest flows of Flow_Pool do
        Fi <- select one from the rest of Flow_Pool
        result_LCS <- LASER (S, Fi)
        S <- select the longest from result_LCS
    i++, end while
    return S

procedure LASER (PacketA[1...m], PacketB[1...n])
    PacketA [m...1] <- Reverse byte stream
    PacketB [n...1] <- Reverse byte stream
    Matrix [m][n]
    while i from 0 to m do
        while j from 0 to n do
            if i = 0 or j = 0, then Matrix[i][j] = 0;
            else if PacketA[i] = PacketB[j], then
                Matrix [i][j] <- 'Diagonal',
                Matrix [i][j] = Matrix [i-1][j-1] + 1;
            else if Matrix[i-1][j] >= Matrix[i][j-1], then
                Matrix[i][j] <- 'Up',
                Matrix[i][j] = Matrix [i-1][j];
            else
                Matrix[i][j] <- 'Up',
                Matrix[i][j] = Matrix [i][j-1];
        end while
    end while
    i <- m-1; j <- n-1 /* Tracking */
    while Matrix[i][j] != 0 do
        if Matrix[i][j] = 'Left', then
            j--
        else if Matrix[i][j] = 'Up', then
            i--
        else if Matrix[i][j] = 'Diagonal', then do
            Substring <- Append PacketA[i]
            if Matrix[i-1][j-1] != 'Diagonal', then
                Substring <- Append special break point character (e.g. '/')
    i--; j--, end while
    while tokenizing substring based on break point do
        if token_length > minimum_substring_length_constraint
            then, result_LCS <- Append token_substring
    end while
    return result_LCS
\end{lstlisting}


\begin{lstlisting}[language=Java, caption=Алгоритм построения дерева подстрок]
    constructTree(substrings)
      Node root = new Node('');
      Tree tree = new Tree(root);
      Sort(substrings);
      for (int i =0; i< substrings.length ; i++)
        addNode(root, new Node(substrings[i]));

    boolean addNode(curNode, newNode )
      if (!isSubFlowSet(curNode, newNode))
        return false;
      boolean succ = false;
      for every child node of curNode
        if (addNode(child, newNode))
          succ = true;
      if (!succ)
        node.addChild(newNode);
      return true
    \end{lstlisting}
